# 服务端代码架构

## 目录结构
```
src/
├── main.rs                 # 程序入口
├── api/                    # API层
│   ├── keys.rs             # 密钥相关API
│   └── mod.rs
├── service/                # 业务逻辑层
│   ├── key_service.rs      # 密钥服务
│   └── mod.rs
├── repository/             # 数据访问层
│   ├── key_repository.rs   # 密钥数据库操作
│   └── mod.rs
├── model/                  # 数据模型层
│   ├── key.rs              # 密钥数据模型
│   └── mod.rs
├── config/                 # 配置模块
│   ├── database.rs         # 数据库配置
│   └── mod.rs
└── utils/                  # 工具函数
    ├── encryption.rs       # 加密工具
    └── mod.rs
```

## 核心模块实现

### 1. 主程序入口 (main.rs)
```rust
use axum::{Router, Server};
use dotenv::dotenv;
use std::net::SocketAddr;
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

mod api;
mod config;
mod model;
mod repository;
mod service;
mod utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 加载环境变量
    dotenv()?;
    
    // 初始化日志
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .with(fmt::layer())
        .init();
    
    // 初始化数据库连接池
    let db_pool = config::database::init_db_pool().await?;
    
    // 构建路由
    let app = Router::new()
        .merge(api::keys::routes())
        .with_state(db_pool);
    
    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("Server running on http://{}", addr);
    
    Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}
```

### 2. 数据库配置 (config/database.rs)
```rust
use once_cell::sync::OnceCell;
use sqlx::{mysql::MySqlPoolOptions, MySqlPool};
use std::env;

static DB_POOL: OnceCell<MySqlPool> = OnceCell::new();

pub async fn init_db_pool() -> Result<&'static MySqlPool, sqlx::Error> {
    let db_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    
    let pool = MySqlPoolOptions::new()
        .max_connections(5)
        .connect(&db_url)
        .await?;
    
    DB_POOL.set(pool).expect("Failed to initialize DB pool");
    Ok(DB_POOL.get().unwrap())
}

pub fn get_pool() -> &'static MySqlPool {
    DB_POOL.get().expect("DB pool not initialized")
}
```

### 3. 数据模型 (model/key.rs)
```rust
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct Key {
    pub id: Option<u64>,
    pub name: String,
    pub encrypted_data: String,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct CreateKeyRequest {
    pub name: String,
    pub data: String,
}

#[derive(Debug, Serialize)]
pub struct KeyResponse {
    pub id: u64,
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
```

### 4. 数据库访问层 (repository/key_repository.rs)
```rust
use super::super::model::key::Key;
use sqlx::{MySqlPool, Result};

pub async fn create_key(pool: &MySqlPool, key: &Key) -> Result<u64> {
    let result = sqlx::query!(
        r#"
        INSERT INTO keys (name, encrypted_data, created_at, updated_at)
        VALUES (?, ?, NOW(), NOW())
        "#,
        key.name,
        key.encrypted_data
    )
    .execute(pool)
    .await?;
    
    Ok(result.last_insert_id())
}

pub async fn get_key_by_id(pool: &MySqlPool, id: u64) -> Result<Option<Key>> {
    let key = sqlx::query_as!(Key,
        r#"
        SELECT id, name, encrypted_data, created_at, updated_at
        FROM keys
        WHERE id = ?
        "#,
        id
    )
    .fetch_optional(pool)
    .await?;
    
    Ok(key)
}

// 其他数据库操作方法...
```

### 5. 业务逻辑层 (service/key_service.rs)
```rust
use super::super::model::key::{CreateKeyRequest, Key, KeyResponse};
use super::super::repository::key_repository;
use super::super::utils::encryption::encrypt_data;
use sqlx::MySqlPool;
use std::error::Error;

pub async fn create_key(
    pool: &MySqlPool,
    request: CreateKeyRequest,
    encryption_key: &str,
) -> Result<KeyResponse, Box<dyn Error>> {
    // 加密数据
    let encrypted_data = encrypt_data(&request.data, encryption_key)?;
    
    // 创建密钥记录
    let key = Key {
        id: None,
        name: request.name,
        encrypted_data,
        created_at: None,
        updated_at: None,
    };
    
    let key_id = key_repository::create_key(pool, &key).await?;
    
    // 获取创建的密钥
    let created_key = key_repository::get_key_by_id(pool, key_id).await?
        .ok_or("Failed to retrieve created key")?;
    
    Ok(KeyResponse {
        id: created_key.id.unwrap(),
        name: created_key.name,
        created_at: created_key.created_at.unwrap(),
    })
}

// 其他业务逻辑方法...
```

### 6. API层 (api/keys.rs)
```rust
use axum::{
    extract::{Json, Path, State},
    http::StatusCode,
    routing::{delete, get, post},
    Router,
};
use serde_json::json;
use sqlx::MySqlPool;

use super::super::model::key::{CreateKeyRequest, KeyResponse};
use super::super::service::key_service;

pub fn routes() -> Router<MySqlPool> {
    Router::new()
        .route("/keys", post(create_key))
        .route("/keys/:id", get(get_key))
        .route("/keys/:id", delete(delete_key))
}

async fn create_key(
    State(pool): State<MySqlPool>,
    Json(request): Json<CreateKeyRequest>,
) -> Result<(StatusCode, Json<KeyResponse>), (StatusCode, String)> {
    // 获取加密密钥（实际应用中应从安全存储获取）
    let encryption_key = std::env::var("ENCRYPTION_KEY")
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "Encryption key not configured".to_string()))?;
    
    let key = key_service::create_key(&pool, request, &encryption_key)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create key: {}", e)))?;
    
    Ok((StatusCode::CREATED, Json(key)))
}

async fn get_key(
    State(pool): State<MySqlPool>,
    Path(id): Path<u64>,
) -> Result<Json<KeyResponse>, (StatusCode, String)> {
    let key = key_service::get_key(&pool, id)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to get key: {}", e)))?
        .ok_or((StatusCode::NOT_FOUND, "Key not found".to_string()))?;
    
    Ok(Json(key))
}

async fn delete_key(
    State(pool): State<MySqlPool>,
    Path(id): Path<u64>,
) -> Result<(StatusCode, Json<serde_json::Value>), (StatusCode, String)> {
    key_service::delete_key(&pool, id)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to delete key: {}", e)))?;
    
    Ok((
        StatusCode::OK,
        Json(json!({ "message": "Key deleted successfully" })),
    ))
}
```

## 中间件配置

### 1. CORS中间件
```rust
use axum::middleware::from_fn;
use axum::{
    http::{header, Request, Response},
    middleware::Next,
};

pub async fn cors_middleware<B>(req: Request<B>, next: Next<B>) -> Result<Response<B>, (StatusCode, String)> {
    let mut response = next.run(req).await;
    
    // 设置CORS响应头
    response.headers_mut().insert(
        header::ACCESS_CONTROL_ALLOW_ORIGIN,
        header::HeaderValue::from_static("*"),
    );
    response.headers_mut().insert(
        header::ACCESS_CONTROL_ALLOW_METHODS,
        header::HeaderValue::from_static("GET, POST, PUT, DELETE, OPTIONS"),
    );
    response.headers_mut().insert(
        header::ACCESS_CONTROL_ALLOW_HEADERS,
        header::HeaderValue::from_static("Content-Type, Authorization"),
    );
    
    Ok(response)
}
```

### 2. 日志中间件
```rust
use axum::{
    extract::MatchedPath,
    middleware::from_fn_with_state,
    routing::get,
    Router,
};
use std::time::Duration;
use tower_http::trace::TraceLayer;
use tracing::{info_span, Span};

pub fn trace_layer() -> TraceLayer<impl Fn(&Request<()>) -> Span + Clone> {
    TraceLayer::new_for_http()
        .make_span_with(|request: &Request<()>| {
            let matched_path = request
                .extensions()
                .get::<MatchedPath>()
                .map(MatchedPath::as_str)
                .unwrap_or("/");
            
            info_span!("http_request", method = %request.method(), path = %matched_path)
        })
        .on_response(|response: &Response<()>, latency: Duration, _span: &Span| {
            tracing::info!("{} {}ms", response.status(), latency.as_millis());
        })
}
```

## 数据库迁移

### 1. 创建迁移文件
```bash
sqlx migrate add -r init_keys_table
```

### 2. 迁移脚本 (migrations/[timestamp]_init_keys_table.up.sql)
```sql
CREATE TABLE IF NOT EXISTS keys (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    encrypted_data TEXT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_name (name)
);
```

### 3. 回滚脚本 (migrations/[timestamp]_init_keys_table.down.sql)
```sql
DROP TABLE IF EXISTS keys;
```

## 环境变量配置 (.env)
```
DATABASE_URL=mysql://user:password@localhost:3306/key_management?ssl-mode=VERIFY_IDENTITY
ENCRYPTION_KEY=your-secure-encryption-key-here
RUST_LOG=info,axum=debug
```

## 依赖配置 (Cargo.toml)
```toml
[package]
name = "key-management-server"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7.5", features = ["tokio"] }
chrono = { version = "0.4", features = ["serde", "utc"] }
dotenv = "0.15.0"
once_cell = "1.18.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.7", features = ["mysql", "runtime-tokio-native-tls", "macros", "chrono"] }
thiserror = "1.0"
tokio = { version = "1.0", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
tower-http = { version = "0.4", features = ["trace"] }
aes-gcm = "0.10.1"
hex = "0.4.3"
```