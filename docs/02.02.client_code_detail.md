# 客户端架构实现细节

## 核心模块划分

1. **UI模块**：负责界面渲染，包含主窗口、密钥管理界面等组件
2. **状态管理**：基于Iced的Elm架构，管理应用状态和消息传递
3. **服务模块**：处理与服务端的通信
4. **存储模块**：使用keyring-rs进行本地凭证存储
5. **加密模块**：实现AES-GCM加密和解密功能
6. **配置模块**：处理应用配置

## Iced 0.13关键特性应用

1. **组件布局**：使用column和row进行界面布局，支持嵌套结构
2. **状态管理**：通过State、Message、View和Update实现响应式UI
3. **异步操作**：支持async/await，结合tokio运行时处理异步任务
4. **主题定制**：使用iced_aw库实现主题切换功能
5. **多窗口管理**：使用iced-multi-window库创建和管理多个窗口

## 状态管理实现

```rust
#[derive(Debug, Clone, Copy)]
enum Message {
    Inc,
    Dec,
    LoadData,
    DataLoaded(Vec<Key>),
    DataLoadError(String),
}

struct AppState {
    count: i32,
    keys: Vec<Key>,
    loading: bool,
    error: Option<String>,
}

impl AppState {
    fn update(&mut self, message: Message) -> Command<Message> {
        match message {
            Message::Inc => {
                self.count += 1;
                Command::none()
            }
            Message::Dec => {
                self.count -= 1;
                Command::none()
            }
            Message::LoadData => {
                self.loading = true;
                self.error = None;
                Command::perform(fetch_keys(), |result| match result {
                    Ok(keys) => Message::DataLoaded(keys),
                    Err(e) => Message::DataLoadError(e.to_string()),
                })
            }
            Message::DataLoaded(keys) => {
                self.keys = keys;
                self.loading = false;
                Command::none()
            }
            Message::DataLoadError(error) => {
                self.error = Some(error);
                self.loading = false;
                Command::none()
            }
        }
    }

    fn view(&self) -> Element<Message> {
        column![
            button("+").on_press(Message::Inc),
            text(self.count).size(20),
            button("-").on_press(Message::Dec),
            button("Load Keys").on_press(Message::LoadData),
            if self.loading {
                text("Loading...").into()
            } else if let Some(error) = &self.error {
                text(format!("Error: {}", error)).style(Style::Error).into()
            } else {
                list(self.keys.iter().map(|key| text(key.name.clone())).collect()).into()
            }
        ].padding(20)
        .align_x(Center)
        .into()
    }
}
```

## 异步操作处理

1. **HTTP请求**：使用reqwest库发送HTTPS请求
   
   ```rust
   async fn fetch_keys() -> Result<Vec<Key>, reqwest::Error> {
    let client = reqwest::Client::new();
    let response = client.get("https://api.example.com/keys")
        .header("Authorization", format!("Bearer {}", get_token()))
        .send()
        .await?;
   
    response.json().await
   }
   ```

2. **取消异步操作**：使用AbortController处理请求超时
   
   ```rust
   async fn fetch_with_timeout(url: &str, timeout: Duration) -> Result<Vec<Key>, String> {
    let controller = AbortController::new();
    let signal = controller.signal();
   
    let timeout_task = tokio::spawn(async move {
        tokio::time::sleep(timeout).await;
        controller.abort();
    });
   
    let fetch_task = tokio::spawn(async move {
        let client = reqwest::Client::new();
        let response = client.get(url)
            .signal(signal)
            .send()
            .await
            .map_err(|e| e.to_string())?;
   
        response.json().await.map_err(|e| e.to_string())
    });
   
    match tokio::try_join!(timeout_task, fetch_task) {
        Ok((_, result)) => result,
        Err(_) => Err("Request timed out".to_string()),
    }
   }
   ```

## 主题定制方案

1. **依赖配置**：
   
   ```toml
   iced_aw = { version = "0.11.0", features = ["menu"] }
   ```

2. **主题切换实现**：
   
   ```rust
   use iced_aw::menu::{MenuBar, Menu, Item};
   ```

fn theme_menu() -> MenuBar<Message> {
    menu_bar![
        Menu::new("主题")
            .item(Item::new("默认主题").on_press(Message::SetTheme(Theme::Default)))
            .item(Item::new("深色主题").on_press(Message::SetTheme(Theme::Dark)))
            .item(Item::new("浅色主题").on_press(Message::SetTheme(Theme::Light)))
    ]
}

```
## 多窗口管理
1. **依赖配置**：
```toml
iced-multi-window = "0.1.0"
```

2. **创建新窗口**：
   
   ```rust
   async fn open_new_window() {
    let window = Window::new()
        .title("新窗口")
        .size(800, 600)
        .build()
        .await
        .unwrap();
   
    window.show().await.unwrap();
   }
   ```

3. **窗口间通信**：
   
   ```rust
   let channel = BroadcastChannel::new("key-manager-channel");
   ```

// 发送消息
channel.send(Message::KeyUpdated(key)).unwrap();

// 接收消息
channel.receive(|message| {
    match message {
        Message::KeyUpdated(key) => {
            // 处理更新的密钥
        }
        _ => {}
    }
});

```
## 错误处理
1. **自定义错误类型**：
```rust
#[derive(Debug)]
enum AppError {
    NetworkError(reqwest::Error),
    CryptoError(aes_gcm::Error),
    StorageError(keyring::Error),
    ParseError(serde_json::Error),
    // 其他错误类型
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::NetworkError(e) => write!(f, "网络错误: {}", e),
            AppError::CryptoError(e) => write!(f, "加密错误: {}", e),
            AppError::StorageError(e) => write!(f, "存储错误: {}", e),
            AppError::ParseError(e) => write!(f, "解析错误: {}", e),
        }
    }
}
```

2. **错误处理中间件**：
   
   ```rust
   fn error_handler(error: AppError) -> Message {
    match error {
        AppError::NetworkError(e) => Message::ShowError(format!("网络错误: {}", e)),
        AppError::CryptoError(e) => Message::ShowError(format!("加密错误: {}", e)),
        AppError::StorageError(e) => Message::ShowError(format!("存储错误: {}", e)),
        AppError::ParseError(e) => Message::ShowError(format!("解析错误: {}", e)),
    }
   }
   ```

## 构建和运行配置

1. **Cargo.toml配置**：
   
   ```toml
   [package]
   name = "key-manager-client"
   version = "0.1.0"
   edition = "2021"
   ```

[dependencies]
iced = { version = "0.13", features = ["tokio", "wgpu"] }
iced_aw = { version = "0.11.0", features = ["menu"] }
iced-multi-window = "0.1.0"
reqwest = { version = "0.11", features = ["json", "stream"] }
tokio = { version = "1.0", features = ["full"] }
keyring = "2.0"
aes-gcm = "0.10"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"

```
2. **主函数实现**：
```rust
fn main() -> iced::Result {
    iced::run("密钥管理客户端", App::update, App::view)
}

struct App;

impl App {
    fn update(state: &mut AppState, message: Message) -> Command<Message> {
        match message {
            // 处理各种消息
            _ => Command::none(),
        }
    }

    fn view(state: &AppState) -> Element<Message> {
        // 构建UI
        column![
            // UI组件
        ].into()
    }
}
```