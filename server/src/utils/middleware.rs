use axum::{http::{header, Request, Response, StatusCode}, middleware::Next};\nuse std::time::Duration;\nuse tower_http::trace::TraceLayer;\nuse tracing::{info_span, Span};\n\n/// CORS中间件，处理跨域请求\npub async fn cors_middleware<B>(mut request: Request<B>, next: Next<B>) -> Response<B> {\n    // 处理OPTIONS预检请求\n    if request.method() == axum::http::Method::OPTIONS {\n        let mut response = Response::new(());\n        *response.status_mut() = StatusCode::NO_CONTENT;\n        set_cors_headers(response.headers_mut());\n        return response.map(|_| unreachable!());\n    }\n\n    // 处理常规请求\n    let response = next.run(request).await;\n    \n    // 为响应添加CORS头\n    let mut response_builder = response.into_parts();\n    set_cors_headers(&mut response_builder.headers);\n    \n    Response::from_parts(response_builder.headers, response_builder.body)\n}\n\n/// 设置CORS响应头\nfn set_cors_headers(headers: &mut axum::http::HeaderMap) {\n    headers.insert(\n        header::ACCESS_CONTROL_ALLOW_ORIGIN,\n        header::HeaderValue::from_static("*"),\n    );\n    headers.insert(\n        header::ACCESS_CONTROL_ALLOW_METHODS,\n        header::HeaderValue::from_static("GET, POST, PUT, DELETE, OPTIONS"),\n    );\n    headers.insert(\n        header::ACCESS_CONTROL_ALLOW_HEADERS,\n        header::HeaderValue::from_static("Content-Type, Authorization"),\n    );\n    headers.insert(\n        header::ACCESS_CONTROL_ALLOW_CREDENTIALS,\n        header::HeaderValue::from_static("true"),\n    );\n}\n\n/// 创建日志中间件\npub fn trace_layer() -> TraceLayer<impl Fn(&Request<()>) -> Span + Clone> {\n    TraceLayer::new_for_http()\n        .make_span_with(|request: &Request<()>| {\n            let matched_path = request\n                .extensions()\n                .get::<axum::extract::MatchedPath>()\n                .map(|mp| mp.as_str())\n                .unwrap_or("/");\n            \n            info_span!("http_request", \n                method = %request.method(), \n                path = %matched_path,\n                remote_addr = tracing::field::Empty\n            )\n        })\n        .on_response(|response: &Response<()>, latency: Duration, span: &Span| {\n            span.record("status", %response.status());\n            tracing::info!("{} {}ms", response.status(), latency.as_millis());\n        })\n}